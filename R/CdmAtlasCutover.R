# @file CdmAtlasCutover
#
# Copyright 2018 Observational Health Data Sciences and Informatics
#
# This file is part of Achilles
# 
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# 
#     http://www.apache.org/licenses/LICENSE-2.0
# 
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
# @author Observational Health Data Sciences and Informatics
# @author Ajit Londhe


#' @title buildCdmSource
#' @author Ajit Londhe
#' @details
#' Creates a CDM source object for use in the package with necessary connection information.
#' If using \code{\link{insertCdmSources}} then connectionString will need to be defined.
#' @examples
#' ## When building a CDM source to insert, and to make it top priority:
#' 
#' buildCdmSource(sourceKey = "TestDb_V123", sourceName = "Test Database v123", dbms = "redshift", cdmDatabaseSchema = "cdm",
#' resultsDatabaseSchema = "ohdsi_results", vocabDatabaseSchema = "cdm", priority = 1,
#' connectionString = "jdbc:redshift://some-redshift-cluster:5439/testdb_v123?user=some-user&password=some-password")
#' @return
#' A CDM source object with the necessary parameters to fulfill SOURCE and SOURCE_DAIMON
#'
#' @param sourceKey                    A unique string identifier for the data source
#' @param sourceName                   The name of the CDM source
#' @param dbms                         The dbms of the CDM source
#' @param cdmDatabaseSchema            The name of the schema where CDM data sits
#' @param resultsDatabaseSchema        The name of the schema where results data sits
#' @param vocabDatabaseSchema          The name of the schema where the vocabulary sits
#' @param sourceId                     An optional value to pre-specify the database index identifier for the data source. 
#'                                     If left NULL, this is either auto-generated by the Repo database, or the next available
#'                                     source_id is obtained.
#' @param connectionString             The JDBC connection string to the CDM source; REQUIRED if trying to insert a CDM source 
#'                                     (\code{\link{insertCdmSources}}), unnecessary when trying to remove a CDM source 
#'                                     (\code{\link{removeCdmSources}})
#' @param priority                     1 = the source become the one Atlas uses by default (e.g. to show record counts)
#'                                     0 = the source will not become the one Atlas uses by default (e.g. to show record counts)
#' @param user                         (OPTIONAL) The user name for the connection to the CDM. Only used if encryption of source credentials is enabled.
#' @param password                     (OPTIONAL) The password for the connection to the CDM. Only used if encryption of source credentials is enabled.
#' 
#' @export
buildCdmSource <- function(sourceKey, 
                           sourceName = NULL, 
                           dbms = NULL, 
                           cdmDatabaseSchema = NULL, 
                           resultsDatabaseSchema = NULL, 
                           vocabDatabaseSchema = NULL,
                           connectionString = NULL, 
                           sourceId = NULL, 
                           priority = 0,
                           user = NULL,
                           password = NULL) {
  
  cdmSource <- {}
  cdmSource$sourceId <- sourceId
  cdmSource$sourceKey <- sourceKey
  cdmSource$sourceName <- sourceName
  cdmSource$dbms <- dbms
  cdmSource$connectionString <- connectionString
  cdmSource$cdmDatabaseSchema <- cdmDatabaseSchema
  cdmSource$resultsDatabaseSchema <- resultsDatabaseSchema
  cdmSource$vocabDatabaseSchema <- vocabDatabaseSchema
  cdmSource$priority <- priority
  cdmSource$user <- user
  cdmSource$password <- password
  return(cdmSource)
}

#' @title removeSources
#' @author Ajit Londhe
#'
#' @details
#' Removes CDM sources and their cohort results from OHDSI Repository. Sources are removed
#' from the SOURCE and SOURCE_DAIMON table, and cohort results for those sources are cleared.
#'
#' @param repoConnectionDetails     A ConnectionDetails object for the OHDSI Repository
#' @param cdmSources                A list of CDM sources, built using CDM source object from \code{\link{buildCdmSource}}
#' @param sqlOnly                   Generate SQL only, don't execute
#' 
#' @export
removeCdmSources <- function(repoConnectionDetails, cdmSources, sqlOnly = FALSE) {
  
  sourceKeys <- sapply(cdmSources, function(cdmSource) { sourceKey <- cdmSource$sourceKey })
  sqls <- c()
  sql <- SqlRender::renderSql(sql = "select source_id from @ohdsiRepositorySchema.source where source_key in (@sourceKeys);", 
                           ohdsiRepositorySchema = repoConnectionDetails$schema, 
                           sourceKeys = paste0(sprintf("'%s'", sourceKeys), collapse = ","))$sql 
  connection <- DatabaseConnector::connect(repoConnectionDetails)
  sourceIds <- DatabaseConnector::querySql(connection = connection, sql = sql)

  if (nrow(sourceIds) == 0) {
    stop("No matching CDM sources found")
  }
  
  sql <- SqlRender::loadRenderTranslateSql(sqlFilename = "ohdsi_repo_deletes.sql", 
                                           packageName = "CdmAtlasCutover", 
                                           dbms = repoConnectionDetails$dbms,
                                           ohdsiRepositorySchema = repoConnectionDetails$schema, 
                                           sourceIds = paste(sourceIds$SOURCE_ID, collapse = ","))
  sqls <- c(sqls, sql)

  sql <- SqlRender::loadRenderTranslateSql(sqlFilename = "remove_sources.sql", 
                                           packageName = "CdmAtlasCutover", 
                                           dbms = repoConnectionDetails$dbms,
                                           ohdsiRepositorySchema = repoConnectionDetails$schema,
                                           sourceIds = paste(sourceIds$SOURCE_ID, collapse = ","))

  sqls <- c(sqls, sql)
  
  if (sqlOnly) {
    if (!dir.exists("output")) { dir.create("output") }
    SqlRender::writeSql(sql = paste(sqls, collapse = "\n"), targetFile = paste("output", "remove_cdm_sources.sql", sep = "/"))
  } else {
    connection <- DatabaseConnector::connect(repoConnectionDetails)
    DatabaseConnector::executeSql(connection = connection, sql = paste(sqls, collapse = "\n"))  
    DatabaseConnector::disconnect(connection)
  }
}


#' @title insertCdmSources
#' @author Ajit Londhe
#'
#' @details
#' Inserts CDM sources into OHDSI Repository. Creates new records in SOURCE and associated records in SOURCE_DAIMON.
#' As these tables may have identity indexes, boolean settings can be used to tell the function to skip instantiating new IDs.
#'
#'
#' @param repoConnectionDetails     A ConnectionDetails object for the OHDSI Repository
#' @param cdmSources                A list of CDM sources, built using CDM source object from \code{\link{buildCdmSource}}
#' @param sourceIdx                 Boolean to indicate if the SOURCE table uses an identity index for source_id
#' @param daimonIdx                 Boolean to indicate if the SOURCE_DAIMON table uses an identity index for source_daimon_id
#' @param sqlOnly                   Generate SQL only, don't execute
#' 
#' @export
insertCdmSources <- function(repoConnectionDetails, 
                             cdmSources, 
                             sourceIdx = FALSE, 
                             daimonIdx = FALSE,
                             sqlOnly = FALSE) {
  
  if ("TRUE" %in% sapply(cdmSources, function(cdmSource) { connectionString <- is.null(cdmSource$connectionString) })) {
    stop("Connection Strings must be defined for each CDM source object in cdmSources list")   
  }
  
  getMaxId <- function(repoConnectionDetails, prefix) {
    
    sql <- SqlRender::renderSql(sql = "select max(@prefix_id) from @ohdsiRepositorySchema.@prefix;", 
                     ohdsiRepositorySchema = repoConnectionDetails$schema, prefix = prefix)$sql 
    connection <- DatabaseConnector::connect(repoConnectionDetails)
    newId <- as.numeric(DatabaseConnector::querySql(connection = connection, sql = sql))
    return(newId)
  }
  
  updateDaimonPriority <- function(sqls, repoConnectionDetails, cdmSource) {
    sql <- SqlRender::loadRenderTranslateSql(sqlFilename = "update_daimon_priority.sql", 
                                             packageName = "CdmAtlasCutover", 
                                             dbms = repoConnectionDetails$dbms, 
                                             ohdsiRepositorySchema = repoConnectionDetails$schema)
    
    sqls <- c(sqls, sql)
  }
  
  sqls <- c()
  maxSourceId <- getMaxId(repoConnectionDetails, "source")
  
  for (i in 1:length(cdmSources)) {
    sourceValues <- {}
    if (!sourceIdx) {
      if (is.null(cdmSources[[i]]$sourceId)) {
        cdmSources[[i]]$sourceId <- maxSourceId + i
      }  
      sourceValues$source_id <- cdmSources[[i]]$sourceId
    }
    
    sourceValues$source_name <- shQuote(cdmSources[[i]]$sourceName) 
    sourceValues$source_key <- shQuote(cdmSources[[i]]$sourceKey) 
    sourceValues$source_connection <- shQuote(cdmSources[[i]]$connectionString)
    sourceValues$source_dialect <- shQuote(cdmSources[[i]]$dbms)
    if (!is.null(cdmSources[[i]]$user) & 
        !is.null(cdmSources[[i]]$password)) {
     
      sourceValues$username <- shQuote(cdmSources[[i]]$user) 
      sourceValues$password <- shQuote(cdmSources[[i]]$password) 
    }
    
    sql <- renderSql(sql = "INSERT INTO @ohdsiRepositorySchema.source (@columns) values (@values);",
                     ohdsiRepositorySchema = repoConnectionDetails$schema,
                     columns = paste0(names(sourceValues), collapse = ","),
                     values = paste0(sourceValues, collapse = ","))$sql
    
    sqls <- c(sqls, sql)
    
    maxDaimonId <- ((i * 3) + getMaxId(repoConnectionDetails, "source_daimon") - 2)
    
    for (daimonType in c(0:2)) {
      
      daimonValues <- {}
      if (!daimonIdx){
        daimonValues$source_daimon_id <- paste0(maxDaimonId + daimonType, " as source_daimon_id")
      }
      daimonValues$priority <- paste0(0, ' as priority')
      daimonValues$daimon_type <- paste0(daimonType,' as daimon_type')
      
      if (daimonType == 0) {
        daimonValues$table_qualifier <- paste0("cast('", cdmSources[[i]]$cdmDatabaseSchema, "' as varchar(255)) as table_qualifier")
      }
      else if (daimonType == 1) {
        daimonValues$table_qualifier <- paste0("cast('", cdmSources[[i]]$vocabDatabaseSchema, "' as varchar(255)) as table_qualifier")
      }
      else {
        daimonValues$table_qualifier <- paste0("cast('", cdmSources[[i]]$resultsDatabaseSchema, "' as varchar(255)) as table_qualifier")
        
        if (cdmSources[[i]]$priority == 1) {
          daimonValues$priority <- paste0(1, ' as priority')
          updateDaimonPriority(sqls = sqls, repoConnectionDetails = repoConnectionDetails, cdmSource = cdmSources[[i]])
        }
      }
      
      sql <- renderSql(sql = "INSERT INTO @ohdsiRepositorySchema.source_daimon (@columns) 
                              select source_id, @values from @ohdsiRepositorySchema.source where source_key = '@sourceKey';",
                       ohdsiRepositorySchema = repoConnectionDetails$schema,
                       columns = paste('source_id', paste0(names(daimonValues), collapse = ","), sep = ","),
                       values = paste0(daimonValues, collapse = ","),
                       sourceKey = cdmSources[[i]]$sourceKey)$sql
      
      sqls <- c(sqls, sql)
    }
  }
  
  if (sqlOnly) {
    
    if (!dir.exists("output")) { dir.create("output") }
    SqlRender::writeSql(sql = paste(sqls, collapse = "\n\n"), targetFile = paste("output", "insert_cdm_sources.sql", sep = "/"))
  } else {
    connection <- connect(repoConnectionDetails)
    executeSql(connection = connection, sql = paste(sqls, collapse = "\n\n"))  
    DatabaseConnector::disconnect(connection)
  }
}

#' @title createOhdsiResultsTables
#' @author Ajit Londhe
#'
#' @details
#' Creates all the OHDSI Results tables needed by Atlas
#' @return
#' none
#'
#' @param cdmSources             The list of databases to cut over
#' @param connectionDetails      A connectionDetails object that can create tables in the CDM
#' @param sqlOnly                Generate SQL only, don't execute
#' 
#' @export
createOhdsiResultsTables <- function (cdmSources, connectionDetails, sqlOnly = FALSE) {
  
  gitPath <- "https://api.github.com/repos/OHDSI/WebAPI/contents/src/main/resources/ddl/results"
  req <- httr::GET(gitPath)
  httr::stop_for_status(req)
  content <- httr::content(req)
  
  ddlFiles <- content[sapply(content, function(d) d$name != "create_index.sql" & 
                               !startsWith(d$name, "init") )]
  ddlUrls <- unlist(lapply(ddlFiles, function(d) d$download_url))
  
  ddlSqls <- lapply(ddlUrls, function(url) {
    sql <- RCurl::getURL(url,
                  ssl.verifyhost = FALSE, 
                  ssl.verifypeer =  FALSE)
    sql <- SqlRender::renderSql(sql = sql,
                                results_schema = cdmSource$resultsDatabaseSchema)$sql
  })
  
  initFiles <- content[sapply(content, function(d) startsWith(tolower(d$name), "init") )]
  initUrls <- unlist(lapply(initFiles, function(d) d$download_url))
  
  initSqls <- lapply(initUrls, function(url) {
    sql <- RCurl::getURL(url,
                         ssl.verifyhost = FALSE, 
                         ssl.verifypeer =  FALSE)
    sql <- SqlRender::renderSql(sql = sql, warnOnMissingParameters = F,
                                results_schema = cdmSource$resultsDatabaseSchema)$sql
  })
  
  sqls <- c(ddlSqls, initSqls)
  
  
  for (cdmSource in cdmSources) {
    
    writeLines(sprintf("Creating OHDSI Results tables for %s", cdmSource$sourceKey))
    finalSql <- paste(sqls, collapse = "\n")
    finalSql <- gsub(pattern = "IF OBJECT_ID", replacement = "\r\nIF OBJECT_ID", x = finalSql)
    
    if (cdmSource$dbms == "pdw") {
      finalSql <- stringr::str_replace_all(finalSql, "IF XACT_STATE\\(\\) = 1 COMMIT;", "")
    }
    if (sqlOnly) {
      if (!dir.exists("output")) { dir.create("output") }
      SqlRender::writeSql(sql = finalSql, 
                          targetFile = file.path("output", 
                                                 sprintf("%s~create_ohdsi_results_tables.sql", 
                                                         cdmSource$sourceKey)))
    } else {
      connectionDetails <- DatabaseConnector::createConnectionDetails(dbms = cdmSource$dbms, 
                                                                      connectionString = cdmSource$connectionString)
      connection <- DatabaseConnector::connect(connectionDetails = connectionDetails)
      DatabaseConnector::executeSql(connection = connection, sql = finalSql)
      DatabaseConnector::disconnect(connection)
    }
  }
}


#' Refresh CDM sources in Atlas
#' @author Ajit Londhe
#' @details
#' Refreshes the source cache that feeds into Atlas. 
#' This step is necessary when making changes to the SOURCE and SOURCE_DAIMON tables,
#' so that the changes propagate to Atlas.
#' 
#' @param baseUrl        The base URL for the WebApi instance, for example:
#'                       "http://api.ohdsi.org:80/WebAPI".
#' 
#' 
#' @export
refreshAtlasSources <- function (baseUrl) {
  .checkBaseUrl <- function(baseUrl) {
    patterns <- list("https?:\\/\\/[a-z0-9]+([\\-\\.]{1}[a-z0-9]+)*\\.[a-z]{2,5}(:[0-9]{1,5})+(\\/.*)?\\/WebAPI$",
                     "https?:\\/\\/(([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(:[0-9]{1,5})+(\\/.*)?\\/WebAPI$")
    results <- lapply(patterns, function(p) {
      result <- grepl(pattern = p, 
                      x = baseUrl, 
                      ignore.case = FALSE)
    })
    return(any(as.logical(results)))
  }
  
  if (!.checkBaseUrl(baseUrl)) {
    stop("Base URL not valid, should be like http://api.ohdsi.org:80/WebAPI")
  }
  
  tryCatch({
    url <- gsub(pattern = "@baseUrl", replacement = baseUrl, x = "@baseUrl/source/refresh")
    
    req <- httr::GET(url)
    httr::stop_for_status(req)
    writeLines("Atlas sources refreshed")
  }, error = function(err) {
    writeLines("Unable to refresh Atlas sources")
  })
}